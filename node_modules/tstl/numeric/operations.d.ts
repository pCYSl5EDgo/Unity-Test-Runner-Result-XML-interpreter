/** @module std */
import { IForwardIterator } from "../iterator/IForwardIterator";
import { General, Writeonly } from "../iterator/IFake";
/**
 * Greatest Common Divider.
 */
export declare function gcd(x: number, y: number): number;
/**
 * Least Common Multiple.
 */
export declare function lcm(x: number, y: number): number;
export declare function iota<ForwardIterator extends General<IForwardIterator<number, ForwardIterator>>>(first: ForwardIterator, last: ForwardIterator, value: number): void;
export declare function accumulate<T, InputIterator extends General<IForwardIterator<T, InputIterator>>>(first: InputIterator, last: InputIterator, init: T, op?: BinaryOperator<T>): T;
export declare function inner_product<X, Y, InputIterator1 extends General<IForwardIterator<X, InputIterator1>>, InputIterator2 extends General<IForwardIterator<Y, InputIterator2>>>(first1: InputIterator1, last1: InputIterator1, first2: InputIterator2, value: X, op1?: BinaryOperator<X>, op2?: BinaryOperator<X, Y>): X;
export declare function adjacent_difference<T, InputIterator extends Readonly<IForwardIterator<T, InputIterator>>, OutputIterator extends Writeonly<IForwardIterator<T, OutputIterator>>>(first: InputIterator, last: InputIterator, output: OutputIterator, op?: BinaryOperator<T>): OutputIterator;
export declare function partial_sum<T, InputIterator extends Readonly<IForwardIterator<T, InputIterator>>, OutputIterator extends Writeonly<IForwardIterator<T, OutputIterator>>>(first: InputIterator, last: InputIterator, output: OutputIterator, op?: BinaryOperator<T>): OutputIterator;
export declare function inclusive_scan<T, InputIterator extends Readonly<IForwardIterator<T, InputIterator>>, OutputIterator extends Writeonly<IForwardIterator<T, OutputIterator>>>(first: InputIterator, last: InputIterator, output: OutputIterator, op?: BinaryOperator<T>, init?: T): OutputIterator;
export declare function exclusive_scan<T, InputIterator extends Readonly<IForwardIterator<T, InputIterator>>, OutputIterator extends Writeonly<IForwardIterator<T, OutputIterator>>>(first: InputIterator, last: InputIterator, output: OutputIterator, init: T, op?: BinaryOperator<T>): OutputIterator;
export declare function transform_inclusive_scan<T, Ret, InputIterator extends Readonly<IForwardIterator<T, InputIterator>>, OutputIterator extends Writeonly<IForwardIterator<Ret, OutputIterator>>>(first: InputIterator, last: InputIterator, output: OutputIterator, binary: BinaryOperator<Ret>, unary: (val: T) => Ret, init?: T): OutputIterator;
export declare function transform_exclusive_scan<T, Ret, InputIterator extends Readonly<IForwardIterator<T, InputIterator>>, OutputIterator extends General<IForwardIterator<Ret, OutputIterator>>>(first: InputIterator, last: InputIterator, output: OutputIterator, init: T, binary: BinaryOperator<Ret>, unary: (val: T) => Ret): OutputIterator;
/**
 * @hidden
 */
declare type BinaryOperator<X, Y = X> = (x: X, y: Y) => X;
export {};
//# sourceMappingURL=operations.d.ts.map