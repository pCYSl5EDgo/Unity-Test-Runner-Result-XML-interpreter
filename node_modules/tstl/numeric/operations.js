"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var operators_1 = require("./operators");
/**
 * Greatest Common Divider.
 */
function gcd(x, y) {
    var _a;
    y = y.valueOf(); // `Number` to `number`
    while (y !== 0)
        _a = __read([y, x % y], 2), x = _a[0], y = _a[1];
    return x;
}
exports.gcd = gcd;
/**
 * Least Common Multiple.
 */
function lcm(x, y) {
    return x * y / gcd(x, y);
}
exports.lcm = lcm;
/* ---------------------------------------------------------
    COMMON ALGORITHMS
--------------------------------------------------------- */
function iota(first, last, value) {
    for (; !first.equals(last); first = first.next())
        first.value = value++;
}
exports.iota = iota;
function accumulate(first, last, init, op) {
    if (op === void 0) { op = operators_1.plus; }
    for (; !first.equals(last); first = first.next())
        init = op(init, first.value);
    return init;
}
exports.accumulate = accumulate;
function inner_product(first1, last1, first2, value, op1, op2) {
    if (op1 === void 0) { op1 = operators_1.plus; }
    if (op2 === void 0) { op2 = operators_1.multiplies; }
    for (; !first1.equals(last1); first1 = first1.next()) {
        value = op1(value, op2(first1.value, first2.value));
        first2 = first2.next();
    }
    return value;
}
exports.inner_product = inner_product;
function adjacent_difference(first, last, output, op) {
    var _a;
    if (op === void 0) { op = operators_1.minus; }
    if (first.equals(last))
        return output;
    // INITIALIZE
    var before;
    _a = __read(_Initialize(first, output), 3), first = _a[0], output = _a[1], before = _a[2];
    // COMPUTE OPERATIONS
    for (; !first.equals(last); first = first.next()) {
        output.value = op(first.value, before);
        before = first.value;
        output = output.next();
    }
    return output;
}
exports.adjacent_difference = adjacent_difference;
function partial_sum(first, last, output, op) {
    var _a;
    if (op === void 0) { op = operators_1.plus; }
    if (first.equals(last))
        return output;
    // INITIALIZE
    var sum;
    _a = __read(_Initialize(first, output), 3), first = _a[0], output = _a[1], sum = _a[2];
    // COMPUTE OPERATIONS
    for (; !first.equals(last); first = first.next()) {
        sum = op(sum, first.value);
        output.value = sum;
        output = output.next();
    }
    return output;
}
exports.partial_sum = partial_sum;
/* ---------------------------------------------------------
    PREFIX SUMS
--------------------------------------------------------- */
function inclusive_scan(first, last, output, op, init) {
    if (op === void 0) { op = operators_1.plus; }
    return transform_inclusive_scan(first, last, output, op, _Capsule, init);
}
exports.inclusive_scan = inclusive_scan;
function exclusive_scan(first, last, output, init, op) {
    if (op === void 0) { op = operators_1.plus; }
    return transform_exclusive_scan(first, last, output, init, op, _Capsule);
}
exports.exclusive_scan = exclusive_scan;
function transform_inclusive_scan(first, last, output, binary, unary, init) {
    var _a;
    if (first.equals(last))
        return output;
    // INITIALIZE
    var before;
    _a = __read(_Transform_initialize(first, output, unary, init), 3), first = _a[0], output = _a[1], before = _a[2];
    // COMPUTE OPERATIONS
    for (; !first.equals(last); first = first.next()) {
        before = binary(before, unary(first.value));
        output.value = before;
        output = output.next();
    }
    return output;
}
exports.transform_inclusive_scan = transform_inclusive_scan;
function transform_exclusive_scan(first, last, output, init, binary, unary) {
    var _a;
    if (first.equals(last))
        return output;
    // INITIALIZE
    var x = unary(first.value);
    var y;
    _a = __read(_Transform_initialize(first, output, unary, init), 3), first = _a[0], output = _a[1], y = _a[2];
    // COMPUTE OPERATIONS
    for (; !first.equals(last); first = first.next()) {
        y = binary(x, y);
        x = unary(first.value);
        output.value = y;
        output = output.next();
    }
    return output;
}
exports.transform_exclusive_scan = transform_exclusive_scan;
/**
 * @hidden
 */
function _Capsule(x) {
    return x;
}
/**
 * @hidden
 */
function _Initialize(first, output, init) {
    return _Transform_initialize(first, output, _Capsule, init);
}
/**
 * @hidden
 */
function _Transform_initialize(first, output, unary, init) {
    // WRITE THE FIRST OR INITIAL VALUE
    var ret = unary(init === undefined
        ? first.value
        : init);
    output.value = ret;
    // RETURNS WITH ADVANCES
    return [first.next(), output.next(), ret];
}
//# sourceMappingURL=operations.js.map