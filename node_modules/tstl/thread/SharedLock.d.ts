/** @module std */
import { _ISharedLockable } from "../base/thread/_ISharedLockable";
import { _ISharedTimedLockable } from "../base/thread/_ISharedTimedLockable";
export declare class SharedLock<Mutex extends IMutex> {
    /**
     * @hidden
     */
    private mutex_;
    constructor(mutex: Mutex);
    try_lock_for: "try_lock_shared_for" extends keyof Mutex ? (ms: number, closure: Closure) => Promise<boolean> : undefined;
    try_lock_until: "try_lock_shared_until" extends keyof Mutex ? (at: Date, closure: Closure) => Promise<boolean> : undefined;
    lock(closure: Closure): Promise<void>;
    try_lock(closure: Closure): Promise<boolean>;
}
export declare namespace SharedLock {
    function lock<Mutex extends Pick<_ISharedLockable, "lock_shared" | "unlock_shared">>(mutex: Mutex, closure: Closure): Promise<void>;
    function try_lock<Mutex extends Pick<_ISharedLockable, "try_lock_shared" | "unlock_shared">>(mutex: Mutex, closure: Closure): Promise<boolean>;
    function try_lock_for<Mutex extends Pick<_ISharedTimedLockable, "try_lock_shared_for" | "unlock_shared">>(mutex: Mutex, ms: number, closure: Closure): Promise<boolean>;
    function try_lock_until<Mutex extends Pick<_ISharedTimedLockable, "try_lock_shared_until" | "unlock_shared">>(mutex: Mutex, at: Date, closure: Closure): Promise<boolean>;
}
export import shared_lock = SharedLock;
/**
 * @hidden
 */
declare type IMutex = _ISharedLockable & Partial<_ISharedTimedLockable>;
/**
 * @hidden
 */
declare type Closure = () => void | Promise<void>;
export {};
//# sourceMappingURL=SharedLock.d.ts.map