"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _SafeLock_1 = require("../base/thread/_SafeLock");
var SharedLock = /** @class */ (function () {
    /* ---------------------------------------------------------
        CONSTRUCTORS
    --------------------------------------------------------- */
    function SharedLock(mutex) {
        this.mutex_ = mutex;
        this.try_lock_for = mutex.try_lock_shared_for instanceof Function
            ? SharedLock.try_lock_for.bind(undefined, this.mutex_)
            : undefined;
        this.try_lock_until = mutex.try_lock_shared_until instanceof Function
            ? SharedLock.try_lock_until.bind(undefined, this.mutex_)
            : undefined;
    }
    /* ---------------------------------------------------------
        COMMON METHODS
    --------------------------------------------------------- */
    SharedLock.prototype.lock = function (closure) {
        return SharedLock.lock(this.mutex_, closure);
    };
    SharedLock.prototype.try_lock = function (closure) {
        return SharedLock.try_lock(this.mutex_, closure);
    };
    return SharedLock;
}());
exports.SharedLock = SharedLock;
(function (SharedLock) {
    /* ---------------------------------------------------------
        STATIC FUNCTIONS
    --------------------------------------------------------- */
    function lock(mutex, closure) {
        return _SafeLock_1._SafeLock.lock(function () { return mutex.lock_shared(); }, function () { return mutex.unlock_shared(); }, closure);
    }
    SharedLock.lock = lock;
    function try_lock(mutex, closure) {
        return _SafeLock_1._SafeLock.try_lock(function () { return mutex.try_lock_shared(); }, function () { return mutex.unlock_shared(); }, closure);
    }
    SharedLock.try_lock = try_lock;
    function try_lock_for(mutex, ms, closure) {
        return _SafeLock_1._SafeLock.try_lock(function () { return mutex.try_lock_shared_for(ms); }, function () { return mutex.unlock_shared(); }, closure);
    }
    SharedLock.try_lock_for = try_lock_for;
    function try_lock_until(mutex, at, closure) {
        return _SafeLock_1._SafeLock.try_lock(function () { return mutex.try_lock_shared_until(at); }, function () { return mutex.unlock_shared(); }, closure);
    }
    SharedLock.try_lock_until = try_lock_until;
})(SharedLock = exports.SharedLock || (exports.SharedLock = {}));
exports.SharedLock = SharedLock;
exports.shared_lock = SharedLock;
//# sourceMappingURL=SharedLock.js.map