/** @module std */
import { ILockable } from "./ILockable";
import { _ITimedLockable } from "../base/thread/_ITimedLockable";
export declare class UniqueLock<Mutex extends IMutex> {
    /**
     * @hidden
     */
    private mutex_;
    constructor(mutex: Mutex);
    try_lock_for: "try_lock_for" extends keyof Mutex ? (ms: number, closure: Closure) => Promise<boolean> : undefined;
    try_lock_until: "try_lock_until" extends keyof Mutex ? (at: Date, closure: Closure) => Promise<boolean> : undefined;
    lock(closure: Closure): Promise<void>;
    try_lock(closure: Closure): Promise<boolean>;
}
export declare namespace UniqueLock {
    function lock<Mutex extends Pick<ILockable, "lock" | "unlock">>(mutex: Mutex, closure: Closure): Promise<void>;
    function try_lock<Mutex extends Pick<ILockable, "try_lock" | "unlock">>(mutex: Mutex, closure: Closure): Promise<boolean>;
    function try_lock_for<Mutex extends Pick<_ITimedLockable, "try_lock_for" | "unlock">>(mutex: Mutex, ms: number, closure: Closure): Promise<boolean>;
    function try_lock_until<Mutex extends Pick<_ITimedLockable, "try_lock_until" | "unlock">>(mutex: Mutex, at: Date, closure: Closure): Promise<boolean>;
}
export import unique_lock = UniqueLock;
/**
 * @hidden
 */
declare type IMutex = ILockable & Partial<_ITimedLockable>;
/**
 * @hidden
 */
declare type Closure = () => void | Promise<void>;
export {};
//# sourceMappingURL=UniqueLock.d.ts.map