/** @module std.experimental */
import { MultiTreeSet } from "../../base/container/MultiTreeSet";
import { SetElementVector } from "../../base/container/SetElementVector";
import { IForwardIterator } from "../../iterator/IForwardIterator";
export declare class FlatMultiSet<Key> extends MultiTreeSet<Key, FlatMultiSet<Key>, FlatMultiSet.Iterator<Key>, FlatMultiSet.ReverseIterator<Key>> {
    /**
     * @hidden
     */
    private key_comp_;
    /**
     * Default Constructor.
     *
     * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Note that, because *equality* is predicated by `!comp(x, y) && !comp(y, x)`, the function must not cover the *equality* like `<=` or `>=`. It must exclude the *equality* like `<` or `>`. Default is {@link less}.
     */
    constructor(comp?: (x: Key, y: Key) => boolean);
    /**
     * Initializer Constructor.
     *
     * @param items Items to assign.
     * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Note that, because *equality* is predicated by `!comp(x, y) && !comp(y, x)`, the function must not cover the *equality* like `<=` or `>=`. It must exclude the *equality* like `<` or `>`. Default is {@link less}.
     */
    constructor(items: Key[], comp?: (x: Key, y: Key) => boolean);
    /**
     * Copy Constructor.
     *
     * @param obj Object to copy.
     */
    constructor(obj: FlatMultiSet<Key>);
    /**
     * Range Constructor.
     *
     * @param first Input iterator of the first position.
     * @param last Input iterator of the last position.
     * @param comp A binary function predicates *x* element would be placed before *y*. When returns `true`, then *x* precedes *y*. Note that, because *equality* is predicated by `!comp(x, y) && !comp(y, x)`, the function must not cover the *equality* like `<=` or `>=`. It must exclude the *equality* like `<` or `>`. Default is {@link less}.
     */
    constructor(first: Readonly<IForwardIterator<Key>>, last: Readonly<IForwardIterator<Key>>, comp?: (x: Key, y: Key) => boolean);
    /**
     * @inheritDoc
     */
    swap(obj: FlatMultiSet<Key>): void;
    /**
     * @inheritDoc
     */
    nth(index: number): FlatMultiSet.Iterator<Key>;
    /**
     * @inheritDoc
     */
    key_comp(): (x: Key, y: Key) => boolean;
    /**
     * @inheritDoc
     */
    lower_bound(key: Key): FlatMultiSet.Iterator<Key>;
    /**
     * @inheritDoc
     */
    upper_bound(key: Key): FlatMultiSet.Iterator<Key>;
    /**
     * @hidden
     */
    protected _Handle_insert({}: {}, {}: {}): void;
    /**
     * @hidden
     */
    protected _Handle_erase({}: {}, {}: {}): void;
}
export declare namespace FlatMultiSet {
    type Iterator<Key> = SetElementVector.Iterator<Key, false, FlatMultiSet<Key>>;
    type ReverseIterator<Key> = SetElementVector.ReverseIterator<Key, false, FlatMultiSet<Key>>;
    const Iterator: typeof SetElementVector.Iterator;
    const ReverseIterator: typeof SetElementVector.ReverseIterator;
    type iterator<Key> = Iterator<Key>;
    type reverse_iterator<Key> = ReverseIterator<Key>;
    const iterator: typeof SetElementVector.Iterator;
    const reverse_iterator: typeof SetElementVector.ReverseIterator;
}
export import flat_multiset = FlatMultiSet;
//# sourceMappingURL=FlatMultiSet.d.ts.map