/** @module std */
import { MultiMap } from "../base/container/MultiMap";
import { IHashMap } from "../base/container/IHashMap";
import { MapElementList } from "../base/container/MapElementList";
import { IForwardIterator } from "../iterator/IForwardIterator";
import { IPair } from "../utility/IPair";
/**
 * Multiple-key Map based on Hash buckets.
 *
 * @author Jeongho Nam <http://samchon.org>
 */
export declare class HashMultiMap<Key, T> extends MultiMap<Key, T, HashMultiMap<Key, T>, HashMultiMap.Iterator<Key, T>, HashMultiMap.ReverseIterator<Key, T>> implements IHashMap<Key, T, false, HashMultiMap<Key, T>> {
    /**
     * @hidden
     */
    private buckets_;
    /**
     * Default Constructor.
     *
     * @param hash An unary function returns hash code. Default is {hash}.
     * @param equal A binary function predicates two arguments are equal. Default is {@link equal_to}.
     */
    constructor(hash?: (key: Key) => number, equal?: (x: Key, y: Key) => boolean);
    /**
     * Initializer Constructor.
     *
     * @param items Items to assign.
     * @param hash An unary function returns hash code. Default is {hash}.
     * @param equal A binary function predicates two arguments are equal. Default is {@link equal_to}.
     */
    constructor(items: IPair<Key, T>[], hash?: (key: Key) => number, equal?: (x: Key, y: Key) => boolean);
    /**
     * Copy Constructor.
     *
     * @param obj Object to copy.
     */
    constructor(obj: HashMultiMap<Key, T>);
    /**
     * Range Constructor.
     *
     * @param first Input iterator of the first position.
     * @param last Input iterator of the last position.
     * @param hash An unary function returns hash code. Default is {hash}.
     * @param equal A binary function predicates two arguments are equal. Default is {@link equal_to}.
     */
    constructor(first: Readonly<IForwardIterator<IPair<Key, T>>>, last: Readonly<IForwardIterator<IPair<Key, T>>>, hash?: (key: Key) => number, equal?: (x: Key, y: Key) => boolean);
    /**
     * @inheritDoc
     */
    clear(): void;
    /**
     * @inheritDoc
     */
    swap(obj: HashMultiMap<Key, T>): void;
    /**
     * @inheritDoc
     */
    find(key: Key): HashMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    count(key: Key): number;
    /**
     * @inheritDoc
     */
    begin(): HashMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    begin(index: number): HashMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    end(): HashMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    end(index: number): HashMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    rbegin(): HashMultiMap.ReverseIterator<Key, T>;
    /**
     * @inheritDoc
     */
    rbegin(index: number): HashMultiMap.ReverseIterator<Key, T>;
    /**
     * @inheritDoc
     */
    rend(): HashMultiMap.ReverseIterator<Key, T>;
    /**
     * @inheritDoc
     */
    rend(index: number): HashMultiMap.ReverseIterator<Key, T>;
    /**
     * @inheritDoc
     */
    bucket_count(): number;
    /**
     * @inheritDoc
     */
    bucket_size(index: number): number;
    /**
     * @inheritDoc
     */
    load_factor(): number;
    /**
     * @inheritDoc
     */
    hash_function(): (key: Key) => number;
    /**
     * @inheritDoc
     */
    key_eq(): (x: Key, y: Key) => boolean;
    /**
     * @inheritDoc
     */
    bucket(key: Key): number;
    /**
     * @inheritDoc
     */
    max_load_factor(): number;
    /**
     * @inheritDoc
     */
    max_load_factor(z: number): void;
    /**
     * @inheritDoc
     */
    reserve(n: number): void;
    /**
     * @inheritDoc
     */
    rehash(n: number): void;
    /**
     * @hidden
     */
    protected _Key_eq(x: Key, y: Key): boolean;
    /**
     * @inheritDoc
     */
    emplace(key: Key, val: T): HashMultiMap.Iterator<Key, T>;
    /**
     * @inheritDoc
     */
    emplace_hint(hint: HashMultiMap.Iterator<Key, T>, key: Key, val: T): HashMultiMap.Iterator<Key, T>;
    /**
     * @hidden
     */
    protected _Insert_by_range<InputIterator extends Readonly<IForwardIterator<IPair<Key, T>, InputIterator>>>(first: InputIterator, last: InputIterator): void;
    /**
     * @hidden
     */
    protected _Handle_insert(first: HashMultiMap.Iterator<Key, T>, last: HashMultiMap.Iterator<Key, T>): void;
    /**
     * @hidden
     */
    protected _Handle_erase(first: HashMultiMap.Iterator<Key, T>, last: HashMultiMap.Iterator<Key, T>): void;
}
export declare namespace HashMultiMap {
    type Iterator<Key, T> = MapElementList.Iterator<Key, T, false, HashMultiMap<Key, T>>;
    type ReverseIterator<Key, T> = MapElementList.ReverseIterator<Key, T, false, HashMultiMap<Key, T>>;
    const Iterator: typeof MapElementList.Iterator;
    const ReverseIterator: typeof MapElementList.ReverseIterator;
    type iterator<Key, T> = Iterator<Key, T>;
    type reverse_iterator<Key, T> = ReverseIterator<Key, T>;
    const iterator: typeof MapElementList.Iterator;
    const reverse_iterator: typeof MapElementList.ReverseIterator;
}
export import unordered_multimap = HashMultiMap;
//# sourceMappingURL=HashMultiMap.d.ts.map