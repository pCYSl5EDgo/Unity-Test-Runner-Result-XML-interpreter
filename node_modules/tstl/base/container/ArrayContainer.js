"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
//================================================================ 
/** @module std.base */
//================================================================
var Container_1 = require("./Container");
var _Repeater_1 = require("../iterator/_Repeater");
var RuntimeError_1 = require("../../exception/RuntimeError");
var LogicError_1 = require("../../exception/LogicError");
/**
 * Base array container.
 *
 * @author Jeongho Nam <http://samchon.org>
 */
var ArrayContainer = /** @class */ (function (_super) {
    __extends(ArrayContainer, _super);
    function ArrayContainer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /* =========================================================
        ACCESSORS
            - ITERATORS
            - INDEXES
    ============================================================
        ITERATORS
    --------------------------------------------------------- */
    /**
     * @inheritDoc
     */
    ArrayContainer.prototype.begin = function () {
        return this.nth(0);
    };
    /**
     * @inheritDoc
     */
    ArrayContainer.prototype.end = function () {
        return this.nth(this.size());
    };
    ArrayContainer.prototype.front = function (val) {
        if (arguments.length === 0)
            return this.at(0);
        else
            this.set(0, val);
    };
    ArrayContainer.prototype.back = function (val) {
        var index = this.size() - 1;
        if (arguments.length === 0)
            return this.at(index);
        else
            this.set(index, val);
    };
    ArrayContainer.prototype.insert = function (pos) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // VALIDATION
        if (pos._Get_array() !== this)
            throw new LogicError_1.InvalidArgument("Error on std." + this.constructor.name + ".insert(): parametric iterator is not this container's own.");
        else if (pos.index() < 0)
            throw new LogicError_1.OutOfRange("Error on std." + this.constructor.name + ".insert(): parametric iterator is directing negative position -> (index = " + pos.index() + ").");
        else if (pos.index() > this.size())
            pos = this.end();
        // BRANCHES
        if (args.length === 1)
            return this._Insert_by_repeating_val(pos, 1, args[0]);
        else if (args.length === 2 && typeof args[0] === "number")
            return this._Insert_by_repeating_val(pos, args[0], args[1]);
        else
            return this._Insert_by_range(pos, args[0], args[1]);
    };
    /**
     * @hidden
     */
    ArrayContainer.prototype._Insert_by_repeating_val = function (position, n, val) {
        var first = new _Repeater_1._Repeater(0, val);
        var last = new _Repeater_1._Repeater(n);
        return this._Insert_by_range(position, first, last);
    };
    ArrayContainer.prototype.erase = function (first, last) {
        if (last === void 0) { last = first.next(); }
        // VALIDATION
        if (first._Get_array() !== this || last._Get_array() !== this)
            throw new LogicError_1.InvalidArgument("Error on std." + this.constructor.name + ".erase(): parametric iterator is not this container's own.");
        else if (first.index() < 0)
            throw new LogicError_1.OutOfRange("Error on std." + this.constructor.name + ".erase(): first is directing negative position -> (first = " + first.index() + ").");
        else if (first.index() > last.index())
            throw new RuntimeError_1.RangeError("Error on std." + this.constructor.name + ".erase(): first iterator has greater index than last -> (first = " + first.index() + ", last = " + last.index() + ").");
        // ADJUSTMENT
        if (first.index() >= this.size())
            return this.end();
        // ERASE ELEMENTS
        return this._Erase_by_range(first, last);
    };
    return ArrayContainer;
}(Container_1.Container));
exports.ArrayContainer = ArrayContainer;
//# sourceMappingURL=ArrayContainer.js.map