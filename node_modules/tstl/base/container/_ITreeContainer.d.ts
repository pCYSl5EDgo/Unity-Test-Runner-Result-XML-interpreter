/** @module std.base */
import { _IAssociativeContainer } from "./_IAssociativeContainer";
import { Iterator } from "../iterator/Iterator";
import { IReverseIterator } from "../iterator/ReverseIterator";
import { Pair } from "../../utility/Pair";
/**
 * @hidden
 */
export interface _ITreeContainer<Key, T extends Elem, SourceT extends _ITreeContainer<Key, T, SourceT, IteratorT, ReverseIteratorT, Elem>, IteratorT extends Iterator<T, SourceT, IteratorT, ReverseIteratorT, Elem>, ReverseIteratorT extends IReverseIterator<T, SourceT, IteratorT, ReverseIteratorT, Elem>, Elem> extends _IAssociativeContainer<Key, T, SourceT, IteratorT, ReverseIteratorT, Elem> {
    /**
     * Get key comparison function.
     *
     * @return The key comparison function.
     */
    key_comp(): (x: Key, y: Key) => boolean;
    /**
     * Get value comparison function.
     *
     * @return The value comparison function.
     */
    value_comp(): (x: Elem, y: Elem) => boolean;
    /**
     * Get iterator to lower bound.
     *
     * @param key Key to search for.
     * @return Iterator to the first element equal or after to the key.
     */
    lower_bound(key: Key): IteratorT;
    /**
     * Get iterator to upper bound.
     *
     * @param key Key to search for.
     * @return Iterator to the first element after the key.
     */
    upper_bound(key: Key): IteratorT;
    /**
     * Get range of equal elements.
     *
     * @param key Key to search for.
     * @return Pair of {@link lower_bound} and {@link upper_bound}.
     */
    equal_range(key: Key): Pair<IteratorT, IteratorT>;
}
/**
 * @hidden
 */
export declare function _Construct<Key, T extends Elem, SourceT extends _ITreeContainer<Key, T, SourceT, IteratorT, ReverseIteratorT, Elem>, IteratorT extends Iterator<T, SourceT, IteratorT, ReverseIteratorT, Elem>, ReverseIteratorT extends IReverseIterator<T, SourceT, IteratorT, ReverseIteratorT, Elem>, Elem>(source: SourceT, Source: _Factory<SourceT>, treeFactory: (comp: (x: Key, y: Key) => boolean) => void, ...args: any[]): void;
/**
 * @hidden
 */
export declare function _Emplacable<Key, T extends Elem, SourceT extends _ITreeContainer<Key, T, SourceT, IteratorT, ReverseIteratorT, Elem>, IteratorT extends Iterator<T, SourceT, IteratorT, ReverseIteratorT, Elem>, ReverseIteratorT extends IReverseIterator<T, SourceT, IteratorT, ReverseIteratorT, Elem>, Elem>(source: SourceT, hint: IteratorT, elem: T): boolean;
/**
 * @hidden
 */
interface _Factory<T, Arguments extends any[] = any[]> {
    new (...args: Arguments): T;
    prototype: T;
}
export {};
//# sourceMappingURL=_ITreeContainer.d.ts.map