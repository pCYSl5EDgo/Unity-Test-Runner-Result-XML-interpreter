/** @module std.base */
import { IContainer } from "../container/IContainer";
import { Iterator } from "./Iterator";
import { IReverseIterator as _IReverse } from "../../iterator/IReverseIterator";
export interface IReverseIterator<T extends Elem, Source extends IContainer<T, Source, Base, This, Elem>, Base extends Iterator<T, Source, Base, This, Elem>, This extends IReverseIterator<T, Source, Base, This, Elem>, Elem = T> extends Readonly<_IReverse<T, Base, This>> {
    /**
     * Get source container.
     *
     * @return The source container.
     */
    source(): Source;
}
/**
 * Base reverse iterator for {@link IContainer}
 *
 * @author Jeongho Nam <http://samchon.org>
 */
export declare abstract class ReverseIterator<T extends Elem, Source extends IContainer<T, Source, Base, This, Elem>, Base extends Iterator<T, Source, Base, This, Elem>, This extends ReverseIterator<T, Source, Base, This, Elem>, Elem = T> implements IReverseIterator<T, Source, Base, This, Elem> {
    /**
     * @hidden
     */
    protected base_: Base;
    /**
     * Initializer Constructor.
     *
     * @param base The base iterator.
     */
    constructor(base: Base);
    /**
     * @hidden
     */
    protected abstract _Create_neighbor(base: Base): This;
    /**
     * Get source container.
     *
     * @return The source container.
     */
    source(): Source;
    /**
     * @inheritDoc
     */
    base(): Base;
    /**
     * @inheritDoc
     */
    readonly value: T;
    /**
     * @inheritDoc
     */
    prev(): This;
    /**
     * @inheritDoc
     */
    next(): This;
    /**
     * @inheritDoc
     */
    equals(obj: This): boolean;
}
//# sourceMappingURL=ReverseIterator.d.ts.map